The program works like it's explain in the coursework 3. However, some modifications have been added. The main idea is that, one (or more) server is running one (or more) distant machine and a client which will manage the synchronisation is running on the local machine (the machine where the user is).
The program contains a client side and one (or more) server side. However, the code is in the same file: So, when we want to launch a server (or daemon) on a machine, we have to add an option in the command line which is called Thus the daemon is running and waits for request from a client.
When we want to launch a client, we have to precise if the source and/or the destination directories are distant. This is done with the option in the command line Four cases are available:
More details about
If the user specifies another case with the option
If the option
The default port number is
The communication between the client and the server(s) are done with socket. When the client (the one who manage the synchronisation) needs information about a directory which is distant, it sends a request to the daemon which is running on this distant machine this information. This request can be something like So, a list of request is defined. These requests (instruction) can be,
Every instruction has to contain 16 characters exactly (16 is defines by the constant This is I order to simplify the sending with socket. So, when an instruction contains less than 16 characters, the char '_' is added at the end. For example, "
The daemon knows what to do according to which instruction is received. Indeed, each case is treated in the When an instruction is received, the daemon and the client know and follow the same protocol. For example, if the instruction
The client: sends the size of the path name, then send the path name
The daemon: receives the size of the path name, then receive the path name, afterward the daemon create the directory.
So, each time the client needs information (or want the server to do something), an instruction is sent and is treated by the server like above.
So, we have to launch this command in this case: the source is distant (on the 10.10.10.16 machine), the destination is local:
First of all, I had to understand exactly how the original program works, how the files are copied, how the file list is created etc...
After that, at the beginning of the modification, I have added the code which treat the option Then, I followed each instruction contained in the synchronisation process and modify it in order to treat the case where a machine (source and/or destination) is distant. Each time modified a step in the process; this modification contains a message sending to a daemon. So, I treated the modification in the client side (message sending) and in the server/daemon side (how treat this instruction). Every time I need to communicate with a daemon, I have to send an instruction. So, I wrote a function called
Here is an example which shows the general case for an instruction sending and the protocol which follows,
Where SendInstruction is defined like this,
void SendInstruction(srcDestType* Where,char* Instruction);
Above is a general example. The same architecture is used every time with some difference in order to adapt each case.
- The system call This function is defined below,
- The system call This function is defined below,
- The system call This is used to change the date of a new file created in the destination directory in order to have exactly the same properties than the source file. This function is defined below,
- The system call The new mode is defined by This function is defined below,
- The system call This function is defined below,
- The system call This function is defined below,
- The system call This is used by the daemon. This function is defined below,
- The system call This function is defined below,
- The system call This function returns this file structured by the This function is defined below,
- The system call This function is defined below,
- The system call This function is defined below,
- The system call This function is defined below,
We can see above that the compilation contains no error. As I have already specified in the design of the coursework 3, in order to compile it, we have to add the constant definition called __LINUX__. So the following line has been added at the beginning,
In order to show some execution example, I have created two directories called
Here is shown the content of these directories (initial content) including the content of the sub-directories, where
More clearly, the schema below shown the directories content,
Above are the initial directories contents. After the execution of dirSync, we want to have exactly the same content (from source to destination). So, the following tests execute dirSync in several case: first of all, the case where
These tests have been executed on a simple machine (because when I have recorded the execution test, I didn't have an access on a network), but the obtained results are exactly the same on two different machine. So, the distant address used here is However, the same execution on two different physical machines would be demonstrated during the demonstration time, on Monday 5 The difference will be the machine address. Instead of using the address 127.0.0.1, the real address machine will be use.
So, three tests follow. In each case, we show the execution print out, then the content of the directories
Case where the source and the destination directories are in the local machine. In this test, no dirSync daemon have to be running (because we are in local),
We can see above the content of the destination directory is exactly the same than the source directory. Unnecessary files have been deleted and necessary files have been copied.
Case where the source is distant (on 127.0.0.1 machine). So, a daemon has to be running on this machine. As it's explains above, if we use 2 different machine, it's exactly the same thing; a daemon has to be running on the distant machine. We use 127.0.0.1 but the effect is the same, we need to use the socket as well,
We can see in this example that the destination directory is the same. The execution time was a bit longer than the first case because we needed to use the socket and the file was sent through the network (not really here because 127.0.0.1 but in a real network, it's the same. 127.0.0.1 is a simulation).
Case where the destination is distant. Like in the previous example, a daemon has to be running on the distant machine (here 127.0.0.1 again),
We can see above that the destination directory is he same than the source directory.
A last case is possible, but not shown here (it would be executed during the demonstration on Monday). This case is where the source and the destination are both distant.
This coursework contains two different parts. First of all, a main part is to understand how a program works. This part requires an analyse because the program is written by another person and sometimes doesn't contain comments. So, now, I understand why to comment a code is very useful and important especially when the program is open source (hence a lot a people may read the code).
The second main part is to find and write a solution to do the modification. First of all, I had to think about the architecture of the modification. After that, I could write the modification and test it on every step.