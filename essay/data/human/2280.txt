This report documents the creation of using a mobile phone to control a buggy's move direction. The whole system can complete a coherent motion: Dial one of these five numbers (2, 4, 6, 8, 5) on the phone keyboard, the buggy will move toward the assigned direction or pause. The system couples together the GSM modem, DTMF decoder, PIC microprocessor and stepper motors on the buggy. To achieve the effective communications between them, a series of methods are designed to meet the specification. Such as the AT commands transmission in the forms of ASCII strings between the GSM modem and the PIC, which are implemented by programs. Results indicate that the remote control of a machine is exercisable and reliable.
The assigned directions are below:
This project has great practical value in remote control application. There are always some dangerous circumstances that people can not access into for the spot direction or control, such as the lab where is full of harmful radioactive rays. So the need for accurate and real-time remote control is necessary and demanding. Remote and intelligent control is a longtime existed but still prospecting area of interest in current research.
My project is an attempt on the remote control to a buggy by a series of communication and processor systems. It can ensure precise and quick direction alter by the instructions you give in faraway distance, which is just by pressing numbers on the digital keyboard of your mobile phone or any fixed telephone. Such an easy function seems to have, it need to go through many parts and links. There are four indispensable elements contained in the buggy, the GSM modem, the DTMF decoder, the PIC microprocessor and the driven boards with their stepper motors, which all act different but related work. To achieve the whole system's successful target requires these parts work smoothly in their section but cooperate well with each other in the entire link.
The buggy changing its direction under the command obviously has something to do with its stepper motors inside. By changing the direction of current flowing through the winding, the pole produced by become opposite making the rotor turned. So if you give the according sequences (high or low input voltage) to the magnet pole, it is possible to realize the direction change movement.
But which direction is ordered by person? This question depends on whether the communication is good enough. The PIC microprocessor will enable the stepper motor's move but it need to get the instruction information from another source, which is DTMF. From the project's title, we learn that DTMF must act an important role in the system. It is true because it decodes the tone information into digital binary forms and sends them to PIC.
The tone of the number we pressed, is transmitted through the GSM wireless communication network. To connect with the GSM modem requires dialing its SIM card number first, then wait for its automatically answer by the successful AT commands stream sent by PIC through the series port. When they begin communicating, the tone of number pressed will arrive at the input of the DTMF through the speaker of the modem.
Under the condition that those links introduced above work properly, the whole system becomes a corporate one. The final target is achieved through the four parts. There are much more knowledge and details in every part. It is a communication system, while also a programmable and processing system. However, it is used for control from people to machine no matter the distance between them, which stand for the advanced applications in carrying out the human's will and instructions.
Researching into all parts of the system then provide sufficient knowledge before starting of the effective link and proper function. From the knowledge gained the most suitable components were chosen and carried forward to the construction stage.
The main function of every part has been discussed in the background research part. The content of this part is designing rational approaches to implement.
The connections between the PIC and stepper motor enable the instructions be transferred and carried out, which means the PIC sending the sequences to make the motor turn and generating the quantities of steps to control its pace. So the program on PIC chip should consider and cover these aspects.
Initializing procedure is done by some "include", "define" and "use" statement.
By the three "include" text from the specified file is used at this point of the compilation. The filename "18F452", "string.h" and "stdio.h" are in <> so the directory with the main source file is searched last.
The options after "fuses" vary depending on the device. This directive defines what fuses should be set in the part when it is programmed. This directive does not affect the compilation but is put in the output files.
This directive affects how the compiler will generate code for input and output instructions that follow. The standard method of doing I/O will cause the compiler to generate code to make an I/O pin either input or output every time it is used. Since the port d will be used as the input from DTMF to PIC while the port b and c as output of PIC to stepper motor, the three "use" statement should appear in the beginning of program.
This sentence tells the compiler the speed of the processor and enables the use of the built-in function: delay_ms() and delay_us(). The speed here is in 20000000 cycles per second.
The functions used in the program such as "PUTS" requires #include "string.h" and
the"GETC" requires #use rs232. The PIN6 and PIN 7 of port C will be used as transmit and receive port. But we will only use the low 4 bits of port C: PIN 0 to 3.
Hence, they don't interfere with each other.
The two different delay settings will lead to different speed of straight and turning movements.
Here comes the exact program controlling the stepper-motor to turn the instructed direction and steps. To achieve this, a dummy program called "Automatic" created.
The basic principle of stepper motor was introduced in the background researchs. The sequences of four pin outputs are "0101" "1001" "1010" "0110" in clockwise turning and "0101" "0110" "1010" "1001" in anti-clockwise turning, so each four pins of PORTB and PORTC on the PIC chip are chosen to send out the sequences. These outputs are seen as Hex values should be given to the PORTB and PORTC regs., so Table 5 shows the matching between the Hex numbers with the outputs (four more pins are added for there are 8 pin in PORTB and PORTC.
To make the stepper-motor turning step by step, a "for" looped "switch" statement were used. Take clockwise turning as an example, if the current state of four pins is "0101", so the next state of four pins will be "1001" and then will be "1010"; then will be "0110". The other case is the same and they all obey the same sequence. The code first written in C language is given below:
What should be stressed is that there may some states other than the four states above which can cause problem to the program. Another " The PIC chip executes each line of statement very fast. So there should be some delay statements enable the PIC chip wait for enough time. The delay statement was shown as follow:
for(i=DELAY;i>0;i--) ;
This statement was added in the end of each " With the help of an " After test the program "Automatic", the behaviour of stepper-motor shows the code can control the stepper-motor turn itself successfully. The tested code was written as a function into the practical program as briefly follows:
It can be seen from this block of code there are two keywords called " They tell the function which direction and how many steps to be taken according to the input. Obviously, the following problem need to be solved it how to link to binary numbers from the DTMF with the "nsteps" and "dir".
Up to now, the function of control has been solved by program. However, the communication between GSM and PIC still remains a problem. When the GSM receiving an incoming call, it first need to answer that call then begin other communicate. This can be realized by transferring AT commands through RS232 serial port, as introduced in background part. With the basic AT commands, we can make, answer or hang up calls directly, select the dialing method (tone or pulse), control the speaker volume, and perform a number of other basic modem operations. The only thing should note is that the modem must be set in the Command mode in which the AT commands be accepted as commands not data.
Refer to the documentation that came with the communications software Hyper-terminal for information before entering the Command mode. The modem acknowledges most commands almost immediately. As soon as you type in a command ending with the carriage return character your modem will respond with OK.
Tabulate the commands that I have tested.
As the tested examples above, we can dial to a destination by using the "ATD" command. The ATD command is used to set a voice, data or fax call. For a data or a fax or a voice call, the application sends the following ASCII string to the modem: ATD<nb> where <nb> is the destination phone number.
We can also answer the call selectively or automatically. When the product receives a call, it sets the RingInd signal and sends the ASCII "RING" or "+CRING: <type>" string to the application. It is testified in Hyper-terminal. Then it waits for the application to accept the call with the ATA command.
In the project, the buggy is determined to receive any incoming call. In other words, everyone can control the buggy using mobile phones with different numbers. So we can set the modem in automatic answering mode, which is S0. Now the AT command here "ATS0=<value>" can meet the application. <value> is used to determine after how many rings it answers.
Since the AT commands are sent through RS232 to modem in the form of ASCII string. This can be realized by just one code:
puts("ATS0=1\r\n"); // after one ring then automatic answer
The built-in function "puts()" in 18F452 sends each character in the string out the RS232 pin using "putc()". After the string is sent a RETURN(13) and LINE-FEED(10) are sent. That's the reason why "\r\n" is after AT commands. In general, "puts" has the same function as "printf()".
After all the programs tested and all steps settled, download the program from PC to the PIC chip in MPLAB. Then the 18F452 PIC chip becomes a powerful and small-size microcontroller on the buggy.
In this part, we have solved two major problems in implementation. They are how to answer the commander's call and how to control the stepper motors on buggy. Holding this design philosophy, we will deal with more practical details in the following implementation session.
In the previous part, we have designed the whole system including the exact interfaces. According to the design philosophy, a figure about the whole buggy system has been drawn and given below. What we should do in this session is linking all components and realizing their function.
From the structure above, we know the function of all parts and the connection between them. First, the whole system needs a DC power supply for every component. Different device requires different voltage power supply. Refer to the data sheet, we learn that the voltage can range from 5 to 32 volts as the power for GSM100T. The PIC18F452 integrated board needs a voltage of 5V while the regulator on it can adjust the 12V to 5V. 12V also meets the two stepper motor's requirement. The DTMF needs a 5V can be solved via connecting to the 5V source on the PIC integrated board. So after all these consideration, we choose a 12V lead acid battery which can provide stable power to all the devices on the buggy at the same time.
Second, as the major communication part, GSM modem is the first one we care about.
Above all, an external antenna is used for picking up and transferring the signals through GSM wireless network. Correctly connect the antenna to the modem as the instructions below.
The next step is installing the SIM card into the SIM card holder on the modem. The SIM card hold will come out by pressing the eject button.
Now we need to connect the modem to the external device, which will cooperate and fulfill the control function together with the modem. The external devices in the project are composed of two parts: DTMF handset socket and PIC microcontroller.
The Y-cable used in here has been introduced in the background section, which connect the 15PIN and 9PIN RS232 serial ports perfectly. There are four Pins in the DTMF 4p4c plug, while the PIN 2 which is "speaker+" will transfer the incoming voice tone feature to the DTMF input. So we only make use of PIN2. Then connect the two RS232 ports. The Y-cable divides the 15PIN on the modem into a 9PIN male and a 4PIN DTMF plug, which enable the serial communication with the 9PIN female port on the PIC integrated board.
The last step about GSM modem is connecting with the power supply to activate.
From the figure above, it is clear that the PIN 3 and 4 on the 4 PIN modem socket are power supply port. Connect the open ending of the included power cord to a DC supply and refer to the instructions for power supply requirement. Connect the connector to the modem. The modem will turn on automatically if the power supply has been correctly connected. The red status indicator on the modem will be lit when power on. After a few seconds it will go flashing slowly.
By far, we have connected the GSM modem with PIC and DTMF. The next step is connecting the DTMF with the PIC board.
MT8870D is the DTMF decoder which will be used on the buggy. It is a very small-sized chip so the breadboard in the 18F452 is big enough. Place the chip into the breadboard and find out its working circuit. According to the components and their connected PIN, link them precisely and correctly.
We will notice that the crystal must be 3.579545MHZ and the capacitors and resistance be in precise quantity. The required 5V DC voltage source can obtain by connecting to the DC voltage source on the PIC integrated board. The DTMF input has already been connected to the "speaker+" from the GSM modem. The outputs (Q1, Q2, Q3 and Q4) need to be connected to low 4 bits of PORT D on PIC, which are PIN 19, 20, 21, 22 (see in Figure 2.3.1), will act as the information input port of PIC.
Outputs of PIC are sequences of 0 and 1 which will control stepper motors by changing the current flowing directions, taking up the low 4 bits of PORT B and PORT C on PIC. According to the program and refer to the figure 4.1.1, it is easy to find that PORTB is in charge of the forward and backward stepper motor while PORTC for the leftward and rightward motor. The following step is connecting them well. The connections between drive boards and stepper motors have been done as well.
The last step for the whole system is that provide the power supply for every part. PIC, drive boards and stepper motors must be connected to the 12V lead acid battery correctly. It is vital to be careful and never be confused about the positive and negative because almost all device are using a same battery.
Now, the system is activated and starting to implement its functions. The steps below specify a whole control and implement process from the instructor to the machine.
Steps:
 Call the number of the GSM modem (a SIM card in it)
 Wait for the modem's answer
 The modem gets the AT command written in the program delivered by PIC through RS232 serial port. So it automatically answer the call, communication 1 connected
 Press one of the five keys on the phone's keyboard
 The modem received the tone through GSM network and sends it to DTMF decoder through its handset's speaker(+) output wire. Communication 2 is linked.
 The DTMF decoder gets the tone and decodes it into binary numbers then sends them to the input port of PIC processor. Communication 3 is established.
 The PIC processor receives these binary numbers and executes the program in itself. The expected result is sending effective control binary numbers to two stepper motors separately, which will drive the magnet rotating in proper way.
 With the stepper motor correctly rotating, we will see the buggy moves in various directions which merely according to the number you pressed.
Note: Everyone can control this buggy by calling its number: "07798517512", no matter how far away you are from it. It doesn't set a restrict caller either. When press "5", it halt the movement. Press any other 4 numbers, it activate again. You can not try to stop its performance by ending the conversation. There is no design for the "end" key, which is a defect of the system.
Tests have been done all the time, including the tests on certain parts and on the whole system. In this stage, some problems were found and necessary modifications and improvements are made.
The time and energy dedicated to this project over the past 7 months has certainly met and the experiences and skills I learned exceeded the original scope of project expectations. There are many challenges and commitments illustrated in this industry technical report to produce such a buggy and many risks taken in trying something new and untested to me. The final result of project is worth the effort of engaging and involving in it. In the process of trying different approaches, I gained a better understanding both on industry and academy. The big practice like this teaches me how industry works and how projects explore one after another.
However, there exist some points still needing to be improved. First, the requirement of resetting every time when the power on, which brings inconvenience to the implementation. I think a deeper research into AT commands of GSM modem can solve this problem. Hundreds of commands can meet almost all the application circumstances. Many of them are seldom noticed and used so there should be one command can solve this.
Second, based on the present function, the buggy can be made only recognize one specific controller. This requires a more advanced compare function which can be done by improving the program. Furthermore, it is also practicable to define additional parameters to the modem by AT commands that instruct the modem to perform certain functions automatically when dialing a phone number. The commands that are used to accomplish this task must be placed in the dial string prior to issuing the command.
Third, the end of every control communication must first ending with a key "5" then pressing the "hang-up" key. If the sequence is opposite, the buggy still moves according to the last command. But normally people would like to use the "hang-up" key to end everything. So this should be reconsidered in the program that making the "hang-up" key has the same function as key "5". It is hard to implement in the project is that the "hang-up" key in the keyboard doesn't have a specific DTMF frequency and can not be decoded into binary numbers as the key "5" does.
Last, the movement speed of buggy can be faster by software methods, such as modifying the program. Basically we control the speed of stepper motor by changing the parameter of cycle delay. However, this method has limitation when the parameter has already been very small. Hence another approach needs to be explored to solve this problem.
In one word, there is great potential in the future development and improvement on both hardware and software in this project.